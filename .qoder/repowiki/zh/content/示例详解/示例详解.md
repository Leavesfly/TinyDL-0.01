# 示例详解

<cite>
**本文档中引用的文件**  
- [SpiralMlpExam.java](file://src/main/java/io/leavesfly/tinydl/example/classify/SpiralMlpExam.java)
- [SpiralDateSet.java](file://src/main/java/io/leavesfly/tinydl/mlearning/dataset/simple/SpiralDateSet.java)
- [Plot.java](file://src/main/java/io/leavesfly/tinydl/utils/Plot.java)
- [MnistMlpExam.java](file://src/main/java/io/leavesfly/tinydl/example/classify/MnistMlpExam.java)
- [MnistDataSet.java](file://src/main/java/io/leavesfly/tinydl/mlearning/dataset/simple/MnistDataSet.java)
- [MlpSinExam.java](file://src/main/java/io/leavesfly/tinydl/example/regress/MlpSinExam.java)
- [SinDataSet.java](file://src/main/java/io/leavesfly/tinydl/mlearning/dataset/simple/SinDataSet.java)
- [RnnCosExam.java](file://src/main/java/io/leavesfly/tinydl/example/regress/RnnCosExam.java)
- [CosDataSet.java](file://src/main/java/io/leavesfly/tinydl/mlearning/dataset/simple/CosDataSet.java)
- [SimpleRnnBlock.java](file://src/main/java/io/leavesfly/tinydl/nnet/block/SimpleRnnBlock.java)
- [Model.java](file://src/main/java/io/leavesfly/tinydl/mlearning/Model.java)
- [MlpBlock.java](file://src/main/java/io/leavesfly/tinydl/nnet/block/MlpBlock.java)
- [SoftmaxCrossEntropy.java](file://src/main/java/io/leavesfly/tinydl/mlearning/loss/SoftmaxCrossEntropy.java)
- [MeanSquaredLoss.java](file://src/main/java/io/leavesfly/tinydl/mlearning/loss/MeanSquaredLoss.java)
- [SGD.java](file://src/main/java/io/leavesfly/tinydl/mlearning/optimize/SGD.java)
</cite>

## 目录
1. [SpiralMlpExam.java 详解](#spiralmlpexamjava-详解)
2. [MnistMlpExam.java 详解](#mnistmlpexamjava-详解)
3. [MlpSinExam.java 详解](#mlpsinexamjava-详解)
4. [RnnCosExam.java 详解](#rnncosexamjava-详解)

## SpiralMlpExam.java 详解

该示例演示了如何使用多层感知机（MLP）对非线性可分的螺旋形数据进行分类，并通过可视化展示决策边界。

### 螺旋数据生成
`SpiralDateSet` 类生成三类螺旋分布的数据点。每类数据通过极坐标公式生成：
- 半径 `radius = 1.0 * rate`（`rate` 从 0 到 1）
- 角度 `theta = j * 4.0 + 4.0 * rate + 噪声`
- 坐标 `x = radius * sin(theta)`, `y = radius * cos(theta)`
其中 `j` 表示类别索引（0,1,2），`i` 表示每个类别中的样本索引。通过添加高斯噪声，使数据更具挑战性。

### MLP 模型构建
使用 `MlpBlock` 构建一个包含两个隐藏层的 MLP 模型：
- 输入层：2 维（x, y 坐标）
- 隐藏层：30 个神经元（两层）
- 输出层：3 维（对应三类）
激活函数默认为 ReLU。模型封装在 `Model` 类中，便于训练和推理。

### 训练与评估
- 优化器：SGD，学习率设为 1.0
- 损失函数：SoftmaxCrossEntropy（交叉熵损失）
- 批大小：10，训练轮数：300
训练过程中，每轮计算平均损失和准确率，并在控制台输出。

### 决策边界可视化
训练完成后，使用 `Plot.java` 工具生成一个 2000 点的网格，输入模型进行预测，得到每个点的类别。通过 `plot.scatter()` 分别绘制原始训练数据和预测结果的散点图，直观展示模型学习到的决策边界。

**Section sources**
- [SpiralMlpExam.java](file://src/main/java/io/leavesfly/tinydl/example/classify/SpiralMlpExam.java#L0-L130)
- [SpiralDateSet.java](file://src/main/java/io/leavesfly/tinydl/mlearning/dataset/simple/SpiralDateSet.java#L0-L79)
- [Plot.java](file://src/main/java/io/leavesfly/tinydl/utils/Plot.java)

## MnistMlpExam.java 详解

该示例展示了如何使用 MLP 模型对 MNIST 手写数字数据集进行分类。

### MNIST 数据集加载
`MnistDataSet` 类负责下载和加载 MNIST 数据集（如果本地不存在）。数据集包含：
- 训练集：60,000 张 28x28 的灰度图像
- 测试集：10,000 张 28x28 的灰度图像
图像数据被展平为 784 维向量，标签为 0-9 的整数。`doPrepare()` 方法读取 IDX 格式的压缩文件，并将像素值归一化到 [0,1] 区间。

### MLP 模型构建
构建一个三层 MLP 模型：
- 输入层：784 维（28*28 像素）
- 隐藏层1：100 个神经元
- 隐藏层2：100 个神经元
- 输出层：10 维（对应 10 个数字）
激活函数使用 Sigmoid。模型同样封装在 `Model` 类中。

### 训练与评估
- 优化器：SGD，学习率设为 0.1
- 损失函数：SoftmaxCrossEntropy
- 批大小：100，训练轮数：50
使用 `Trainer` 类进行训练，`AccuracyEval` 作为评估器。训练完成后，`trainer.evaluate()` 在测试集上计算分类准确率。预期准确率约为 91%。

**Section sources**
- [MnistMlpExam.java](file://src/main/java/io/leavesfly/tinydl/example/classify/MnistMlpExam.java#L0-L69)
- [MnistDataSet.java](file://src/main/java/io/leavesfly/tinydl/mlearning/dataset/simple/MnistDataSet.java#L0-L181)
- [MlpBlock.java](file://src/main/java/io/leavesfly/tinydl/nnet/block/MlpBlock.java)
- [SoftmaxCrossEntropy.java](file://src/main/java/io/leavesfly/tinydl/mlearning/loss/SoftmaxCrossEntropy.java)
- [SGD.java](file://src/main/java/leavesfly/tinydl/mlearning/optimize/SGD.java)

## MlpSinExam.java 详解

该示例演示了如何使用 MLP 模型对带有噪声的正弦波数据进行回归拟合。

### 正弦波数据生成
`SinDataSet` 类生成 100 个带有噪声的正弦波数据点：
- 输入 `x`：在 [0,1) 区间内随机采样
- 输出 `y`：`sin(2πx) + noise`，其中 `noise` 为随机噪声
数据通过 `prepare()` 方法准备，并划分为批次。

### MLP 模型构建
构建一个简单的 MLP 模型用于回归：
- 输入层：1 维（x 值）
- 隐藏层：10 个神经元
- 输出层：1 维（y 值）
激活函数使用 Sigmoid。模型结构由 `MlpBlock` 定义。

### 回归训练
- 优化器：SGD，学习率设为 0.2
- 损失函数：MeanSquaredLoss（均方误差损失）
- 训练轮数：10,000
训练过程手动循环，每次前向传播计算预测值，计算损失，反向传播更新梯度，最后调用 `optimizer.update()` 更新参数。损失值随训练轮数下降。

### 预测结果可视化
训练完成后，使用 `Plot.java` 绘制原始数据点（散点图）和模型预测的曲线（折线图）。预期结果是预测曲线能够较好地拟合正弦波的趋势，但由于噪声存在，不会完全重合。

**Section sources**
- [MlpSinExam.java](file://src/main/java/io/leavesfly/tinydl/example/regress/MlpSinExam.java#L0-L69)
- [SinDataSet.java](file://src/main/java/io/leavesfly/tinydl/mlearning/dataset/simple/SinDataSet.java#L0-L34)
- [MeanSquaredLoss.java](file://src/main/java/io/leavesfly/tinydl/mlearning/loss/MeanSquaredLoss.java)
- [Plot.java](file://src/main/java/io/leavesfly/tinydl/utils/Plot.java)

## RnnCosExam.java 详解

该示例展示了如何使用简单 RNN（SimpleRNN）对余弦序列进行时间序列预测。

### 余弦序列数据生成
`CosDataSet` 类生成用于训练和测试的序列数据：
- 训练数据：`sin(2πt)` 序列，用于预测下一个值
- 测试数据：`cos(2πt)` 序列，用于评估模型泛化能力
数据被构造成输入-输出对：输入是当前值 `x_t`，输出是下一个值 `x_{t+1}`。`bpttLength` 参数控制反向传播通过时间的长度。

### RNN 模型构建
使用 `SimpleRnnBlock` 构建一个简单的 RNN 模型：
- 输入大小：1
- 隐藏层大小：20
- 输出大小：1
RNN 模型具有内部状态，能够捕捉序列中的时间依赖关系。

### 时间序列预测训练
- 优化器：SGD，学习率设为 0.01
- 损失函数：MeanSquaredLoss
- 训练轮数：100
训练过程的关键点：
1.  **状态重置**：每轮训练开始前调用 `model.resetState()` 清除隐藏状态，防止状态在轮次间传递。
2.  **序列处理**：对于每个批次，循环处理序列中的每个时间步，将当前输入送入模型，得到预测，并与真实下一个值计算损失。
3.  **损失累积**：将一个批次内所有时间步的损失累加，然后进行反向传播和参数更新。
4.  **计算图切断**：在批次处理结束后调用 `loss.unChainBackward()` 切断计算图，防止梯度回传到上一个批次，实现截断的 BPTT (Truncated BPTT)。

### Teacher Forcing 技术
本示例中，模型的输入是真实的历史数据（`xArray[j]`），而不是模型自己上一步的预测。这种使用真实值作为下一步输入的方法称为 **Teacher Forcing**。它有助于模型在训练初期更稳定地学习，避免了错误累积的问题。

**Section sources**
- [RnnCosExam.java](file://src/main/java/io/leavesfly/tinydl/example/regress/RnnCosExam.java#L0-L91)
- [CosDataSet.java](file://src/main/java/io/leavesfly/tinydl/mlearning/dataset/simple/CosDataSet.java#L0-L48)
- [SimpleRnnBlock.java](file://src/main/java/io/leavesfly/tinydl/nnet/block/SimpleRnnBlock.java)
- [Model.java](file://src/main/java/io/leavesfly/tinydl/mlearning/Model.java#L0-L100)